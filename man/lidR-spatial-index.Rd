% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_spatial_index.R
\name{lidR-spatial-index}
\alias{lidR-spatial-index}
\alias{sensor}
\alias{sensor<-}
\alias{index}
\alias{index<-}
\title{Spatial index}
\usage{
sensor(las, h = FALSE)

sensor(las) <- value

index(las, h = FALSE)

index(las) <- value
}
\arguments{
\item{las}{An object of class \link[lidR:LAS-class]{LAS} or \link[lidR:LAScatalog-class]{LAScatalog}.}

\item{h}{boolean. Human readable. Everything is stored as integers that are understood
internally. Use \code{h = TRUE} for user readable output.}

\item{value}{integer or character. A code for refereeing to a sensor type or a spatial
index type. Use one of \code{"unknown"}, \code{"als"}, \code{"tls"}, \code{"uav"}, \code{"dap"}, \code{"multispectral"}
for sensor and one of \code{"auto"}, \code{"gridpartition"}, \code{"voxelpartition"}, \code{"quadtree"}, \code{"octree"}
for spatial index.}
}
\description{
This document explains how to process point-clouds taking advantage of different spatial
indexes available in the lidR package. lidR can use several types of spatial indexes to
apply algorithms (that need a spatial indexing) as fast as possible. The choice of the spatial
index depends on the type of point-cloud that is processed and the algorithm that is performed.
lidR can use a grid partition, a voxel partition, a quadtree or an octree. See details.
}
\details{
From lidR (>= 3.1.0), a \link[=LAS-class]{LAS} object records the sensor used to sample
the point-cloud (ALS, TLS, UAV, DAP) as well as the spatial index that must be used
for processing the point cloud. This can be set manually by the user but the simplest is
to use one of the \link[=readLAS]{read*LAS()} function. By default a point-cloud is associated
to a sensor and the best spatial index is chosen on-the-fly depending on the algorithm
applied. It is possible to force the use of a specific spatial index.

Information relative to the spatial indexing are stored in slot \verb{@index} that contains
a \code{list} with two elements:
\itemize{
\item \code{sensor}: an integer that records the sensor type
\item \code{index}: an integer that records the spatial index to used
}

By default the spatial index code is 0 ("automatic") meaning that each function is free
to choose a different spatial index depending on the recorded sensor. If the code is not
0 then each function will be forced to used the spatial index that is imposed.

\link[=LAScatalog-class]{LAScatalog} objects also record such information that is automatically
propagated to the LAS objects when processing.

Note: before version 3.1.0 point-clouds were all considered as ALS because lidR was preliminary
designed for ALS. Consequently for legacy and backward compatibility reasons \code{readLAS()}
and \code{readALSLAS()} are actually equivalent. \code{readLAS()} tags the point cloud with "unknown"
sensor while \code{readALSLAS()} tags it with 'ALS' both behave the same and
especially behave the same than in versions < 3.1. As a consequence using \code{readLAS()} provides
the same performance (no degradation) than in previous version while using one of \code{read*LAS()}
may improve the performance.
}
\examples{
LASfile <- system.file("extdata", "example.laz", package="rlas")
las <- readLAS(LASfile)

# By default the sensor and spatial index codes are 0
sensor(las)
index(las)

# Codes are used internally and not intended to be known by users
# Use h option for human readable output
sensor(las, h = TRUE)
index(las, h = TRUE)

# Modification of the sensor enables to select a better spatial index
# when processing the point-cloud.
sensor(las) <- "tls"
sensor(las, h = TRUE)
index(las, h = TRUE)

# Modification of the spatial index forces to use one of the avaialble
# spatial index.
index(las) <- "quadtree"
sensor(las, h = TRUE)
index(las, h = TRUE)

# The simplest way to take advantage of appropriated spatial indexing is
# to use one of read*LAS().
las <- readTLSLAS(LASfile)
sensor(las, h = TRUE)
index(las, h = TRUE)

# But for some specific point-cloud / algorithm it might be advised to force
# the use of a specific spatial index to perform the computation faster
index(las) <- "voxelpartition"
index(las, h = TRUE)

# With a LAScatalog, spatial indexing informations are propagated to the
# different chunks
ctg = readTLSLAScatalog(LASfile)
index(ctg) <- "voxelpartition"
sensor(ctg, h = TRUE)
index(ctg, h = TRUE)


}
